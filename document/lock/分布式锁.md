## 演示工程搭建

> 一个电商平台，该平台上有5000个商品，每个商品初始库存数量为1，总共有5000个用户在同一时刻下单购买商品，每个用户下单时会对所选商品库存数量进行一次减操作。如果最终所有商品的库存数量均为0，则表示所有商品已经售罄，如果有任何一个商品的库存数量大于0，则表示出现了并发问题（竞态条件问题（Race Condition）是指多个线程或进程在访问共享资源时，由于执行顺序不确定或者执行时间差异较大，导致最终的结果与执行顺序有关，出现了不确定性和不可预测性的情况。
>
> 竞态条件问题通常出现在并发编程中，例如多线程对同一个变量进行读写、多进程访问同一个文件等情况。为了更好地演示竞态条件问题，我们可以采用另一种方式来测试。
>
> 假设有5000个请求，我们将库存初始值设置为0，每个请求对库存进行一次加操作。如果最终库存数量为5000，则说明所有请求均已成功增加库存，没有出现并发问题。反之，如果最终库存数量小于5000，则说明出现了竞态条件问题。

![](https://oss.yiki.tech/img/202305030506707.png)

![](https://oss.yiki.tech/img/202305030506461.png)

![](https://oss.yiki.tech/img/202305030508529.png)

![](https://oss.yiki.tech/img/202305030510152.png)

### 并发问题解释

![](https://oss.yiki.tech/img/202305030546638.png)

### 测试本地锁存在的问题

#### 不加锁下的并发

> 可以发现并没有加到 5000值仅有 114。出现并发问题

![](https://oss.yiki.tech/img/202305030506461.png)

![](https://oss.yiki.tech/img/202305030517532.png)

![](https://oss.yiki.tech/img/202305030518711.png)

#### 添加本地锁的并发

> 添加 synchronized 本地锁, 将 number 值重置为 0 进行压测。得数是 5000 看似没有出现并发性问题，但是 本地锁只能在单个JVM内部生效，无法跨服务、跨工程、跨服务器实现协调和同步。

![](https://oss.yiki.tech/img/202305030556873.png)

![](https://oss.yiki.tech/img/202305030559362.png)

#### 测试集群下本地锁存在的问题

> copy 2 份实例模拟集群环境 将 number 设置为 0 重新压测 5000次。最终结果 2360 原因是极限情况下 3 台服务可能同时放入一个线程 同时到达 都将 num 转换为某一个数字 ++. 理论值在 5000 / 3 至 5000 间

![](https://oss.yiki.tech/img/202305030602517.png)

![](https://oss.yiki.tech/img/202305030604129.png)

![](https://oss.yiki.tech/img/202305030605651.png)

![](https://oss.yiki.tech/img/202305030607673.png)

![](https://oss.yiki.tech/img/202305030613114.png)

## 分布式锁实现

| 基于什么实现              | 实现方式                                                     | 考量                                        |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------- |
| 基于 MySQL 关系型数据库   | 设置主键, 把写入主键做为 lock<br />INSERT INTO lock_table (lock_name) VALUES ('my_lock_name') ON DUPLICATE KEY UPDATE lock_name = lock_name;<br />DELETE FROM lock_table WHERE lock_name = 'my_lock_name'; | MySQL 实现方式最简单 > Redis > Zk           |
| 基于 Redis 非关系型数据库 | 加锁 setnx, 解锁 del, 重试                                   | Redis 性能最高 偏向 AP > Zk 偏向 CP > MySQL |
| 基于 Zookeeper 实现       | 略                                                           | Zk 追求 CP 可靠性 > Redis & MySQL           |

### 基于 Redis 实现分布式锁

![](https://oss.yiki.tech/img/202305030618219.png)

#### 分布式锁加锁解锁添加 else 的必要性

> 执行方法本质是一个入栈出栈的执行过程, testLock() 第一次执行压栈。未获取到锁进入 if() 等待睡眠时间结束后进行重试，继续压栈。如果重试后还是没有获取到锁，继续进入 if() 等待睡眠结束然后压栈。直到获取锁成功执行完后依次出栈。
>
> `本质一个请求我们只希望它对 number 进行 + 1，在不加 else 的情况下，每次重试都会使程序重新调用 testLock() 方法，从而重新执行对资源 number 的 + 操作。这样就会导致一个请求重试多少次，就会让我们多 + 多少次，增加了资源的不必要修改和开销。`因此，在加了 else 的情况下，只有成功获取到锁时才进行对资源的修改，避免了重复操作

![](https://oss.yiki.tech/img/202305030626224.png)

```java
    // 基于 redis 实现分布式锁。借助于 setnx 指令 当 key 不存在即设置成功返回 1 当 key 存在即设置失败返回 0(加锁 解锁 重试)分布式锁特征: 独占排他互斥使用
    public void testLock() {
        /**
         * 加锁 setIfAbsent 类似与 setNx 当 key 不存在即设置成功 否 则 失败
         *      分布式锁本质就是对 key 的争抢, 谁先设置成功谁就先获取锁
         */
        Boolean flag = redisTemplate.opsForValue().setIfAbsent("lock", "lock");

        if (!flag) {
            // 加锁失败, 进行递归调用进行重试
            try {
                // 睡眠一段时间(如果不设置睡眠不停的重试也可能会导致栈内存溢出) 模拟让抢到锁的线程执行业务逻辑 减少竞争
                Thread.sleep(30);
                // 设置锁(加锁)失败重新调用该方法进行重试
                testLock();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } else {
            String number = redisTemplate.opsForValue().get("number");

            if (StringUtils.isBlank(number)) {
                redisTemplate.opsForValue().set("number", "1");
            }

            int num = Integer.parseInt(number);

            redisTemplate.opsForValue().set("number", String.valueOf(++num));

            // 释放锁
            redisTemplate.delete("lock");
        }
    }
```

![](https://oss.yiki.tech/img/202305030634716.png)